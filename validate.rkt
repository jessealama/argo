#lang racket/base

(require json)

(module+ test
  (require rackunit))

(require (only-in (file "resolve.rkt")
                  resolve-schema-wrt-id))

(require (only-in (file "parameters.rkt")
                  current-id))

(require (only-in (file "parse.rkt")
                  parse-json-bytes))

(require (only-in http/request
                  uri&headers->path&header
                  connect-uri
                  start-request
                  purify-port/log-debug
                  read-entity/bytes))

(require (only-in (file "json.rkt")
                  json-boolean?
                  json-number?
                  json-string?
                  json-array?
                  json-object?
                  json-true-value?
                  json-false-value?
                  has-property?
                  property-value
                  object-properties
                  remove-property
                  array-items
                  array-length
                  json-equal?
                  count-properties
                  has-type?))

(require (only-in racket/function
                  identity))

(require (only-in (file "format.rkt")
                  date-time?
                  email?
                  hostname?
                  ipv4?
                  ipv6?
                  uri?
                  uri-reference?
                  uri-template?
                  json-pointer?))

(require (only-in (file "regexp.rkt")
                  ecma-262-regexp-matches?))

(require (only-in (file "schema.rkt")
                  json-schema?))

(require (only-in racket/list
                  check-duplicates))

;; assumes that schema is a json-boolean? value
(define (valid-wrt-schema/boolean? data schema)
  (json-true-value? schema))

;; assumes that schema is a json-object? value
(define (valid-wrt-schema? data schema)
  (unless (jsexpr? data)
    (raise-user-error "Data is not a jsexpr? value." data))
  (unless (jsexpr? schema)
    (raise-user-error "Schema is not a jsexpr? value." schema))
  (unless (json-schema? schema)
    (raise-user-error "Scheme is not a JSON schema."))
  (define original-schema schema)
  ;; (log-error (format "original data = ~a" data))
  ;; (log-error (format "original schema = ~a" schema))
  (define (valid? data schema)
    (define (has? property)
      (has-property? schema property))
    (define (remove property)
      (remove-property schema property))
    (define (get property)
      (property-value schema property))
    (define (valid-w/o? property)
    (valid? data (remove property)))
    ;; (log-error (format "data = ~a" data))
    ;; (log-error (format "schema = ~a" schema))
    (cond ((json-boolean? schema)
           (json-true-value? schema))
          ((json-object? schema)
           (cond ((has? '$id)
                  (parameterize ([current-id (get '$id)])
                    (valid-w/o? '$id)))
                 ((has? '$ref)
                  (define-values (resolved-schema loaded?)
                    (resolve-schema-wrt-id (get '$ref) (current-id) original-schema))
                  ; (log-error (format "resolved schema = ~a" resolved-schema))
                  (cond (loaded?
                         (and (valid-wrt-schema? data resolved-schema)
                              (valid-w/o? '$ref)))
                        (else
                         (log-error (format "Failed to resolve schema at \"~a\". (Or it is not a JSON schema.)" (get '$ref)))
                         #f)))
                 ((has? 'multipleOf)
                  (if (json-number? data)
                      (if (exact-integer? (/ data (get 'multipleOf)))
                          (valid-w/o? 'multipleOf)
                          #f)
                      (valid-w/o? 'multipleOf)))
                 ((has? 'exclusiveMaximum)
                  (let ([m (get 'exclusiveMaximum)])
                    (if (json-number? data)
                        (and (< data m)
                             (valid-w/o? 'exclusiveMaximum))
                        (valid-w/o? 'exclusiveMaximum))))
                 ((has? 'exclusiveMinimum)
                  (let ([m (get 'exclusiveMinimum)])
                    (if (json-number? data)
                        (and (> data m)
                             (valid-w/o? 'exclusiveMinimum))
                        (valid-w/o? 'exclusiveMinimum))))
                 ((has? 'maximum)
                  (let ([m (get 'maximum)])
                    (if (json-number? data)
                        (and (<= data m)
                             (valid-w/o? 'maximum))
                        (valid-w/o? 'maximum))))
                 ((has? 'minimum)
                  (let ([m (get 'minimum)])
                    (if (json-number? data)
                        (and (>= data m)
                             (valid-w/o? 'minimum))
                        (valid-w/o? 'minimum))))
                 ((has? 'maxLength)
                  (if (json-string? data)
                      (if (<= (string-length data) (get 'maxLength))
                          (valid-w/o? 'maxLength)
                          #f)
                      (valid-w/o? 'maxLength)))
                 ((has? 'minLength)
                  (if (json-string? data)
                      (if (>= (string-length data) (get 'minLength))
                          (valid-w/o? 'minLength)
                          #f)
                      (valid-w/o? 'minLength)))
                 ((has? 'pattern)
                  (if (json-string? data)
                      (if (ecma-262-regexp-matches? (get 'pattern) data)
                          (valid-w/o? 'pattern)
                          #f)
                      (valid-w/o? 'pattern)))
                 ((has? 'items)
                  ; (log-error "considering items")
                  (if (json-array? data)
                      (let ([v (get 'items)])
                        (and (cond ((json-schema? v)
                                    (andmap (lambda (item)
                                              (valid? item v))
                                            (array-items data)))
                                   ((json-array? v)
                                    (let ([checks (for/list ([i (array-items data)]
                                                             [s (array-items v)])
                                                    (valid? i s))])
                                      (andmap identity checks)))
                                   (else
                                    (error "Value of items is neither a JSON schema nor an array.")))
                             (valid-w/o? 'items)))
                      (valid-w/o? 'items)))
                 ((has? 'additionalItems)
                  (if (json-array? data)
                      ;; TODO not done yet
                      #t
                      (valid-w/o? 'additionalItems)))
                 ((has? 'maxItems)
                  (if (json-array? data)
                      (if (<= (array-length data) (get 'maxItems))
                          (valid-w/o? 'maxItems)
                          #f)
                      (valid-w/o? 'maxItems)))
                 ((has? 'minItems)
                  ; (log-error "Working on minItems")
                  (if (json-array? data)
                      (and (>= (array-length data) (get 'minItems))
                           (valid-w/o? 'minItems))
                      (valid-w/o? 'minItems)))
                 ((has? 'uniqueItems)
                  ; (log-error "considering uniqueItems")
                  (if (json-false-value? (get 'uniqueItems))
                      (valid-w/o? 'uniqueItems)
                      (if (json-array? data)
                          (let ([check (check-duplicates (array-items data)
                                                         json-equal?)])
                            (and (eq? check #f)
                                 (valid-w/o? 'uniqueItems)))
                          (valid-w/o? 'uniqueItems))))
                 ((has? 'contains)
                  (if (json-array? data)
                      (let ([s (get 'contains)])
                        (if (ormap (lambda (item)
                                     (valid? item s))
                                   (array-items data))
                            (valid-w/o? 'contains)
                            #f))
                      (valid-w/o? 'contains)))
                 ((has? 'maxProperties)
                  (if (json-object? data)
                      (let ([c (count-properties data)])
                        (if (<= c (get 'maxProperties))
                            (valid-w/o? 'maxProperties)
                            #f))
                      (valid-w/o? 'maxProperties)))
                 ((has? 'minProperties)
                  (if (json-object? data)
                      (let ([c (count-properties data)])
                        (if (>= c (get 'minProperties))
                            (valid-w/o? 'minProperties)
                            #f))
                      (valid-w/o? 'minProperties)))
                 ((has? 'required)
                  (if (json-object? data)
                      (let ([required (get 'required)])
                        (and (andmap (lambda (prop)
                                       (has-property? data prop))
                                     (array-items (get 'required)))
                             (valid-w/o? 'required)))
                      (valid-w/o? 'required)))
                 ((has? 'properties)
                  (let ([properties (get 'properties)])
                    ; (log-error "Working on properties:")
                    (define (satisfies-property? prop)
                      ; (log-error (format "considering property \"~a\"" prop))
                      (or (not (has-property? data prop))
                          (valid? (property-value data prop)
                                  (property-value properties prop))))
                    (cond ((json-object? data)
                           (and (andmap satisfies-property?
                                        (object-properties properties))
                                (valid-w/o? 'properties)))
                          (else
                           (valid-w/o? 'properties)))))
                 ((has? 'patternProperties)
                  (let ([properties (get 'patternProperties)])
                    (define (satisfies-property? prop)
                      (andmap (lambda (prop)
                                (and (has-property? data prop)
                                     (has-property? properties prop)
                                     (valid? (property-value data prop)
                                             (property-value properties prop))))
                              (filter (lambda (prop)
                                        (ormap (lambda (other-prop)
                                                 (ecma-262-regexp-matches? prop other-prop))
                                               (object-properties data)))
                                      (object-properties schema)))
                      (or (not (has-property? data prop))
                          (valid? (property-value data
                                                  prop)
                                  (property-value properties
                                                  prop))))
                    (cond ((json-object? data)
                           (and (andmap satisfies-property?
                                        (object-properties properties))
                                (valid-w/o? 'patternProperties)))
                          (else
                           (valid-w/o? 'patternProperties)))))
                 ;; additionalProperties
                 ((has? 'dependencies)
                  (let ([deps (get 'dependencies)])
                    (define (satisfies-dependency? prop dependency)
                      (or (not (has-property? deps prop))
                          (let ([dependency-value (property-value deps prop)])
                            (cond ((json-array? dependency-value)
                                   (andmap (lambda (dep-prop)
                                             (has-property? data dep-prop))
                                           (array-items dependency-value)))
                                  ((json-object? dependency-value)
                                   (valid? data dependency-value))
                                  (else
                                   (error "Unexpected non-array, non-object dependency value:" dependency-value))))))
                    (cond ((json-object? data)
                           (and (andmap (lambda (prop)
                                          (satisfies-dependency? prop
                                                                 (property-value data prop)))
                                        (object-properties data))
                                (valid-w/o? 'dependencies)))
                          (else
                           (valid-w/o? 'dependencies)))))
                 ((has? 'propertyNames)
                  (let ([s (get 'propertyNames)]
                        [items (object-properties data)])
                    (and (andmap (lambda (item)
                                   (valid? item s))
                                 items)
                         (valid-w/o? 'propertyNames))))
                 ((has? 'enum)
                  (and (ormap (lambda (x)
                                (json-equal? x data))
                              (array-items (get 'enum)))
                       (valid-w/o? 'enum)))
                 ((has? 'const)
                  (and (json-equal? data (get 'const))
                       (valid-w/o? 'const)))
                 ((has? 'type)
                  ; (log-error "considering type")
                  (and (has-type? data (get 'type))
                       (valid-w/o? 'type)))
                 ((has? 'allOf)
                  (and (andmap (lambda (s)
                                 (valid? data s))
                               (array-items (get 'allOf)))
                       (valid-w/o? 'allOf)))
                 ((has? 'anyOf)
                  (and (ormap (lambda (s)
                                (valid? data s))
                              (array-items (get 'anyOf)))
                       (valid-w/o? 'anyOf)))
                 ((has? 'oneOf)
                  (let* ([items (array-items (get 'oneOf))]
                         [succeeds (filter (lambda (s)
                                             (valid? data s))
                                           items)])
                    (and (= (length succeeds) 1)
                         (valid-w/o? 'oneOf))))
                 ((has? 'not)
                  (let ([s (get 'not)])
                    (and (not (valid? data s))
                         (valid-w/o? 'not))))
                 ((has? 'format)
                  (let ([f (get 'format)])
                    (and (cond ((string=? f "date-time")
                                (date-time? data))
                               ((string=? f "email")
                                (email? data))
                               ((string=? f "hostname")
                                (hostname? data))
                               ((string=? f "ipv4")
                                (ipv4? data))
                               ((string=? f "ipv6")
                                (ipv6? data))
                               ((string=? f "uri")
                                (uri? data))
                               ((string=? f "uri-reference")
                                (uri-reference? data))
                               ((string=? f "uri-template")
                                (uri-template? data))
                               ((string=? f "json-pointer")
                                (json-pointer? data))
                               (else
                                (error "Unknown format: " f)))
                         (valid-w/o? 'format))))
                 (else
                  #t)))
          (else
           (raise-user-error "Schema should be either a JSON boolean or a JSON object." schema))))
  (valid? data schema))

(provide valid-wrt-schema?)
