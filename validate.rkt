#lang racket/base

(require json)

(module+ test
  (require rackunit))

(require (only-in (file "json.rkt")
                  json-boolean?
                  json-number?
                  json-string?
                  json-array?
                  json-object?
                  json-true-value?
                  json-false-value?
                  has-property?
                  property-value
                  object-properties
                  remove-property
                  array-items
                  array-length
                  json-equal?
                  count-properties
                  has-type?))

(require (only-in (file "regexp.rkt")
                  ecma-262-regexp-matches?))

(require (only-in (file "schema.rkt")
                  json-schema?))

(require (only-in racket/list
                  check-duplicates))

;; assumes that schema is a json-boolean? value
(define (valid-wrt-schema/boolean? data schema)
  (json-true-value? schema))

;; assumes that schema is a json-object? value
(define (valid-wrt-schema/object? data schema)
  (define (has? property)
    (has-property? schema property))
  (define (remove property)
    (remove-property schema property))
  (define (get property)
    (property-value schema property))
  (define (valid-w/o? property)
    (valid-wrt-schema/object? data (remove property)))
  (cond ((has? 'multipleOf)
         (if (json-number? data)
             (if (exact-integer? (/ data (get 'multipleOf)))
                 (valid-w/o? 'multipleOf)
                 #f)
             (valid-w/o? 'multipleOf)))
        ((has? 'maximum)
         (if (json-number? data)
             (if (<= data (get 'maximum))
                 (valid-w/o? data 'maximum)
                 #f)
             (valid-w/o? 'maximum)))
        ((has? 'exclusiveMaximum)
         (if (json-number? data)
             (if (< data (get 'exclusiveMaximum))
                 (valid-w/o? 'exclusiveMaximum)
                 #f)
             (valid-w/o? 'exclusiveMaximum)))
        ((has? 'minimum)
         (if (json-number? data)
             (if (>= (get 'minimum) data)
                 (valid-w/o? 'minimum)
                 #f)
             (valid-w/o? 'minimum)))
        ((has? 'exclusiveMinimum)
         (if (json-number? data)
             (if (> data (get 'exclusiveMinimum))
                 (valid-w/o? 'exclusiveMinimum)
                 #f)
             (valid-w/o? 'exclusiveMinimum)))
        ((has? 'maxLength)
         (if (json-string? data)
             (if (<= (string-length data) (get 'maxLength))
                 (valid-w/o? 'maxLength)
                 #f)
             (valid-w/o? 'maxLength)))
        ((has? 'minLength)
         (if (json-string? data)
             (if (>= (string-length data) (get 'minLength))
                 (valid-w/o? 'minLength)
                 #f)
             (valid-w/o? 'minLength)))
        ((has? 'pattern)
         (if (json-string? data)
             (if (ecma-262-regexp-matches? (get 'pattern) data)
                 (valid-w/o? 'pattern)
                 #f)
             (valid-w/o? 'pattern)))
        ((has? 'items)
         (if (json-array? data)
             (let ([v (get 'items)])
               (cond ((json-schema? v)
                      (andmap (lambda (item)
                                (valid-wrt-schema? item v))
                              (array-items data)))
                     ((json-array? v)
                      ;; TODO not done yet
                      )
                     (else
                      ;; log error: shouldn't happen if schema really
                      ;; is a schema
                      #f)))
             (valid-w/o? 'items)))
        ((has? 'additionalItems)
         (if (json-array? data)
             ;; TODO not done yet
             #t
             (valid-w/o? 'additionalItems)))
        ((has? 'maxItems)
         (if (json-array? data)
             (if (<= (array-length data) (get 'maxItems))
                 (valid-w/o? 'maxItems)
                 #f)
             (valid-w/o? 'maxItems)))
        ((has? 'minItems)
         (if (json-array? data)
             (if (>= (array-length data) (get 'minItems))
                 (valid-w/o? 'minItems)
                 #f)
             (valid-w/o? 'minItems)))
        ((has? 'uniqueItems)
         (if (json-false-value? (get 'uniqueItems))
             (valid-w/o? 'uniqueItems)
             (if (json-array? data)
                 (let ([check (check-duplicates (array-items data)
                                                json-equal?)])
                   (if (eq? check #f)
                       (valid-w/o? 'uniqueItems)
                       #f))
                 #f)))
        ((has? 'contains)
         (if (json-array? data)
             (let ([s (get 'contains)])
               (if (ormap (lambda (item)
                            (valid-wrt-schema? item s))
                          (array-items data))
                   (valid-w/o? 'contains)
                   #f))
             (valid-w/o? 'contains)))
        ((has? 'maxProperties)
         (if (json-object? data)
             (let ([c (count-properties data)])
               (if (<= c (get 'maxProperties))
                   (valid-w/o? 'maxProperties)
                   #f))
             (valid-w/o? 'maxProperties)))
        ((has? 'minProperties)
         (if (json-object? data)
             (let ([c (count-properties data)])
               (if (>= c (get 'minProperties))
                   (valid-w/o? 'minProperties)
                   #f))
             (valid-w/o? 'minProperties)))
        ((has? 'required)
         (if (json-object? data)
             (let ([required (get 'required)])
               (if (andmap (lambda (prop)
                             (has-property? data prop))
                           (array-items (get 'required)))
                   (valid-w/o? 'required)
                   #f))
             (valid-w/o? 'required)))
        ((has? 'properties)
         (let ([properties (get 'properties)])
           (define (satisfies-property? prop)
             (or (not (has-property? data prop))
                 (valid-wrt-schema? (property-value data prop)
                                    (property-value properties prop))))
           (cond ((json-object? data)
                (and (andmap satisfies-property?
                             (object-properties properties))
                     (valid-w/o? 'properties)))
               (else
                (valid-w/o? 'properties)))))
        ((has? 'patternProperties)
         (let ([properties (get 'patternProperties)])
           (define (satisfies-property? prop)
             (andmap (lambda (prop)
                       (valid-wrt-schema? (property-value data prop)
                                          (property-value properties prop)))
                     (filter (lambda (prop)
                               (ormap (lambda (other-prop)
                                        (ecma-262-regexp-matches? prop other-prop))
                                      (object-properties data)))
                             (object-properties schema)))
             (or (not (has-property? data prop))
                 (valid-wrt-schema? (property-value data
                                                    prop)
                                    (property-value properties
                                                    prop))))
           (cond ((json-object? data)
                  (and (andmap satisfies-property?
                               properties)
                       (valid-w/o? 'patternProperties)))
                 (else
                  (valid-w/o? 'patternProperties)))))
        ;; additionalProperties
        ((has? 'dependencies)
         (let ([deps (get 'dependencies)])
           (define (satisfies-dependency? prop dependency)
             (let ([dependency-value (property-value deps
                                                     dependency)])
               (cond ((json-array? dependency-value)
                      (or (not (has-property? data prop))
                          (andmap (lambda (dep-prop)
                                    (has-property? data
                                                               dep-prop)))))
                     ((json-object? dependency-value)
                      (or (not (has-property? data prop))
                          (valid-wrt-schema? data dependency-value)))
                     (else
                      (error "Unexpected non-array, non-object dependency value:" dependency-value)))))
           (cond ((json-object? data)
                  (andmap (lambda (prop)
                            (satisfies-dependency? prop
                                                   (property-value data prop)))
                          (object-properties data)
                          (valid-w/o? 'properties)))
                 (else
                  (valid-w/o? 'properties))))
         (if (json-object? data)
             (let ([deps (get 'dependencies)])
               (let ([deps-props (object-properties deps)])
                 ;; not done
                 #f))
             (valid-w/o? 'dependencies)))
        ((has? 'propertyNames)
         (let ([s (get 'propertyNames)]
               [items (object-properties data)])
           (and (andmap (lambda (item)
                          (valid-wrt-schema? item s))
                        items)
                (valid-w/o? 'propertyNames))))
        ((has? 'enum)
         (and (ormap (lambda (x)
                       (json-equal? x data))
                     (array-items (get 'enum)))
              (valid-w/o? 'enum)))
        ((has? 'const)
         (and (json-equal? data (get 'const))
              (valid-w/o? 'const)))
        ((has? 'type)
         (let ([t (property-value 'type)])
           (and (has-type? data (get 'type))
                (valid-w/o? 'type))))
        ((has? 'allOf)
         (and (andmap (lambda (s)
                        (valid-wrt-schema? data s))
                      (array-items (get 'allOf)))
              (valid-w/o? 'allOf)))
        ((has? 'anyOf)
         (and (ormap (lambda (s)
                       (valid-wrt-schema? data s))
                     (array-items (get 'anyOf)))
              (valid-w/o? 'anyOf)))
        ((has? 'oneOf)
         (let* ([items (array-items (get 'oneOf))]
                [succeeds (filter (lambda (s)
                                    (valid-wrt-schema? data s))
                                  items)])
           (and (= (length succeeds) 1)
                (valid-w/o? 'oneOf))))
        ((has? 'not)
         (let ([s (get 'not)])
           (and (not (valid-wrt-schema? data s))
                (valid-w/o? 'not))))))

(define (valid-wrt-schema? data schema)
  (unless (jsexpr? data)
    (raise-user-error "Data is not a jsexpr? value." data))
  (unless (jsexpr? schema)
    (raise-user-error "Schema is not a jsexpr? value." schema))
  (unless (json-schema? schema)
    (raise-user-error "Scheme is not a JSON schema."))
  (cond ((json-boolean? schema)
         (valid-wrt-schema/boolean? data schema))
        ((json-object? schema)
         (valid-wrt-schema/object? data schema))
        (else
         (raise-user-error "Schema should be either a JSON boolean or a JSON object." schema))))

(provide valid-wrt-schema?)

(module+ test)

(module+ main
  ;; Main entry point, executed when run with the `racket` executable or DrRacket.
  )
