#lang racket/base

(module+ test
  (require rackunit)
  (require (only-in (file "util.rkt")
                    let-test)))

(require (only-in (file "resolve.rkt")
                  resolve-schema-wrt-id))

(require (only-in (file "parameters.rkt")
                  current-id))

(require (only-in ejs
                  ejsexpr?
                  ejs-boolean?
                  ejs-object?
                  ejs-number?
                  ejs-string?
                  ejs-array?
                  equal-ejsexprs?))

(require (only-in (file "parse.rkt")
                  parse-json))

(require (only-in http/request
                  uri&headers->path&header
                  connect-uri
                  start-request
                  purify-port/log-debug
                  read-entity/bytes))

(require (only-in (file "json.rkt")
                  json-true-value?
                  json-false-value?
                  has-property?
                  property-value
                  object-properties
                  remove-property
                  array-items
                  array-length
                  count-properties
                  has-type?))

(require (only-in racket/function
                  identity))

(require (only-in (file "format.rkt")
                  date-time?
                  email?
                  hostname?
                  ipv4?
                  ipv6?
                  uri?
                  uri-reference?
                  uri-template?
                  json-pointer?))

(require (only-in (file "regexp.rkt")
                  ecma-262-regexp-matches?))

(require (only-in (file "schema.rkt")
                  json-schema?))

(require (only-in racket/list
                  check-duplicates))

(define (adheres-to-schema? data schema)
  (define original-schema schema)
  ; (log-error (format "original data = ~a" data))
  ; (log-error (format "original schema = ~a" schema))
  (define (valid? data schema)
    (define (has? property)
      (has-property? schema property))
    (define (remove property)
      (remove-property schema property))
    (define (get property)
      (property-value schema property))
    (define (valid-w/o? property)
    (valid? data (remove property)))
    ; (log-error (format "data = ~a" data))
    ; (log-error (format "schema = ~a" schema))
    (cond ((ejs-boolean? schema)
           (json-true-value? schema))
          ((ejs-object? schema)
           (cond ((has? '$id)
                  (parameterize ([current-id (get '$id)])
                    (valid-w/o? '$id)))
                 ((has? '$ref)
                  (define-values (resolved-schema loaded?)
                    (resolve-schema-wrt-id (get '$ref) (current-id) original-schema))
                  ; (log-error (format "resolved schema = ~a" resolved-schema))
                  (cond (loaded?
                         (and (adheres-to-schema? data resolved-schema)
                              (valid-w/o? '$ref)))
                        (else
                         (log-error (format "Failed to resolve schema at \"~a\". (Or it is not a JSON schema.)" (get '$ref)))
                         #f)))
                 ((has? 'multipleOf)
                  (if (ejs-number? data)
                      (if (exact-integer? (/ data (get 'multipleOf)))
                          (valid-w/o? 'multipleOf)
                          #f)
                      (valid-w/o? 'multipleOf)))
                 ((has? 'exclusiveMaximum)
                  (let ([m (get 'exclusiveMaximum)])
                    (if (ejs-number? data)
                        (and (< data m)
                             (valid-w/o? 'exclusiveMaximum))
                        (valid-w/o? 'exclusiveMaximum))))
                 ((has? 'exclusiveMinimum)
                  (let ([m (get 'exclusiveMinimum)])
                    (if (ejs-number? data)
                        (and (> data m)
                             (valid-w/o? 'exclusiveMinimum))
                        (valid-w/o? 'exclusiveMinimum))))
                 ((has? 'maximum)
                  (let ([m (get 'maximum)])
                    (if (ejs-number? data)
                        (and (<= data m)
                             (valid-w/o? 'maximum))
                        (valid-w/o? 'maximum))))
                 ((has? 'minimum)
                  (let ([m (get 'minimum)])
                    (if (ejs-number? data)
                        (and (>= data m)
                             (valid-w/o? 'minimum))
                        (valid-w/o? 'minimum))))
                 ((has? 'maxLength)
                  (if (ejs-string? data)
                      (if (<= (string-length data) (get 'maxLength))
                          (valid-w/o? 'maxLength)
                          #f)
                      (valid-w/o? 'maxLength)))
                 ((has? 'minLength)
                  (if (ejs-string? data)
                      (if (>= (string-length data) (get 'minLength))
                          (valid-w/o? 'minLength)
                          #f)
                      (valid-w/o? 'minLength)))
                 ((has? 'pattern)
                  (if (ejs-string? data)
                      (if (ecma-262-regexp-matches? (get 'pattern) data)
                          (valid-w/o? 'pattern)
                          #f)
                      (valid-w/o? 'pattern)))
                 ((has? 'items)
                  ; (log-error "considering items")
                  (if (ejs-array? data)
                      (let ([v (get 'items)])
                        (and (cond ((json-schema? v)
                                    (andmap (lambda (item)
                                              (valid? item v))
                                            (array-items data)))
                                   ((ejs-array? v)
                                    (let ([checks (for/list ([i (array-items data)]
                                                             [s (array-items v)])
                                                    (valid? i s))])
                                      (andmap identity checks)))
                                   (else
                                    (log-error "Value of items is neither a JSON schema nor an array.")
                                    #f))
                             (valid-w/o? 'items)))
                      (valid-w/o? 'items)))
                 ((has? 'additionalItems)
                  (if (ejs-array? data)
                      ;; TODO not done yet
                      #t
                      (valid-w/o? 'additionalItems)))
                 ((has? 'additionalProperties)
                  (if (ejs-object? data)
                      (let ([schema-for-additional (get 'additionalProperties)]
                            [schema-properties (if (ejs-object? schema)
                                                   (if (has? 'properties)
                                                       (object-properties (get 'properties))
                                                       (list))
                                                   (list))])
                        (let ([more-properties (filter (lambda (prop)
                                                         (not (member prop
                                                                      schema-properties)))
                                                       (object-properties data))])
                          (and (andmap (lambda (prop)
                                         (adheres-to-schema? (property-value data prop)
                                                             schema-for-additional))
                                       more-properties)
                               (valid-w/o? 'additionalProperties))))
                      (valid-w/o? 'additionalProperties)))
                 ((has? 'maxItems)
                  (if (ejs-array? data)
                      (if (<= (array-length data) (get 'maxItems))
                          (valid-w/o? 'maxItems)
                          #f)
                      (valid-w/o? 'maxItems)))
                 ((has? 'minItems)
                  ; (log-error "Working on minItems")
                  (if (ejs-array? data)
                      (and (>= (array-length data) (get 'minItems))
                           (valid-w/o? 'minItems))
                      (valid-w/o? 'minItems)))
                 ((has? 'uniqueItems)
                  ; (log-error "considering uniqueItems")
                  (if (json-false-value? (get 'uniqueItems))
                      (valid-w/o? 'uniqueItems)
                      (if (ejs-array? data)
                          (let ([check (check-duplicates (array-items data)
                                                         equal-ejsexprs?)])
                            (and (eq? check #f)
                                 (valid-w/o? 'uniqueItems)))
                          (valid-w/o? 'uniqueItems))))
                 ((has? 'contains)
                  (if (ejs-array? data)
                      (let ([s (get 'contains)])
                        (if (ormap (lambda (item)
                                     (valid? item s))
                                   (array-items data))
                            (valid-w/o? 'contains)
                            #f))
                      (valid-w/o? 'contains)))
                 ((has? 'maxProperties)
                  (if (ejs-object? data)
                      (let ([c (count-properties data)])
                        (if (<= c (get 'maxProperties))
                            (valid-w/o? 'maxProperties)
                            #f))
                      (valid-w/o? 'maxProperties)))
                 ((has? 'minProperties)
                  (if (ejs-object? data)
                      (let ([c (count-properties data)])
                        (if (>= c (get 'minProperties))
                            (valid-w/o? 'minProperties)
                            #f))
                      (valid-w/o? 'minProperties)))
                 ((has? 'required)
                  (if (ejs-object? data)
                      (let ([required (get 'required)])
                        (and (andmap (lambda (prop)
                                       (has-property? data prop))
                                     (array-items required))
                             (valid-w/o? 'required)))
                      (valid-w/o? 'required)))
                 ((has? 'properties)
                  (let ([properties (get 'properties)])
                    ; (log-error "Working on properties:")
                    (define (satisfies-property? prop)
                      ; (log-error (format "considering property \"~a\"" prop))
                      (or (not (has-property? data prop))
                          (valid? (property-value data prop)
                                  (property-value properties prop))))
                    (cond ((ejs-object? data)
                           (and (andmap satisfies-property?
                                        (object-properties properties))
                                (valid-w/o? 'properties)))
                          (else
                           (valid-w/o? 'properties)))))
                 ((has? 'patternProperties)
                  (let ([properties-schema (get 'patternProperties)])
                    ; (log-error (format "patternProperties = ~a" properties-schema))
                    (cond ((ejs-object? data)
                           (and (andmap (lambda (schema-prop)
                                          (andmap (lambda (data-prop)
                                                    (or (not (ecma-262-regexp-matches? (symbol->string schema-prop)
                                                                                       (symbol->string data-prop)))
                                                        (valid? (property-value data data-prop)
                                                                (property-value properties-schema schema-prop))))
                                                  (object-properties data)))
                                        (object-properties properties-schema))
                                (valid-w/o? 'patternProperties)))
                          (else
                           (valid-w/o? 'patternProperties)))))
                 ;; dependencies
                 ((has? 'dependencies)
                  (let ([deps (get 'dependencies)])
                    (define (satisfies-dependency? prop dependency)
                      (or (not (has-property? deps prop))
                          (let ([dependency-value (property-value deps prop)])
                            (cond ((ejs-array? dependency-value)
                                   (andmap (lambda (dep-prop)
                                             (has-property? data dep-prop))
                                           (array-items dependency-value)))
                                  ((ejs-object? dependency-value)
                                   (valid? data dependency-value))
                                  (else
                                   (log-error "Unexpected non-array, non-object dependency value:" dependency-value)
                                   #f)))))
                    (cond ((ejs-object? data)
                           (and (andmap (lambda (prop)
                                          (satisfies-dependency? prop
                                                                 (property-value data prop)))
                                        (object-properties data))
                                (valid-w/o? 'dependencies)))
                          (else
                           (valid-w/o? 'dependencies)))))
                 ((has? 'propertyNames)
                  (let ([s (get 'propertyNames)]
                        [items (object-properties data)])
                    (and (andmap (lambda (item)
                                   (valid? item s))
                                 items)
                         (valid-w/o? 'propertyNames))))
                 ((has? 'enum)
                  (and (ormap (lambda (x)
                                (equal-ejsexprs? x data))
                              (array-items (get 'enum)))
                       (valid-w/o? 'enum)))
                 ((has? 'const)
                  (and (equal-ejsexprs? data (get 'const))
                       (valid-w/o? 'const)))
                 ((has? 'type)
                  ; (log-error "considering type")
                  (and (has-type? data (get 'type))
                       (valid-w/o? 'type)))
                 ((has? 'allOf)
                  (and (andmap (lambda (s)
                                 (valid? data s))
                               (array-items (get 'allOf)))
                       (valid-w/o? 'allOf)))
                 ((has? 'anyOf)
                  (and (ormap (lambda (s)
                                (valid? data s))
                              (array-items (get 'anyOf)))
                       (valid-w/o? 'anyOf)))
                 ((has? 'oneOf)
                  (let* ([items (array-items (get 'oneOf))]
                         [succeeds (filter (lambda (s)
                                             (valid? data s))
                                           items)])
                    (and (= (length succeeds) 1)
                         (valid-w/o? 'oneOf))))
                 ((has? 'not)
                  (let ([s (get 'not)])
                    (and (not (valid? data s))
                         (valid-w/o? 'not))))
                 ((has? 'format)
                  (let ([f (get 'format)])
                    (and (cond ((string=? f "date-time")
                                (date-time? data))
                               ((string=? f "email")
                                (email? data))
                               ((string=? f "hostname")
                                (hostname? data))
                               ((string=? f "ipv4")
                                (ipv4? data))
                               ((string=? f "ipv6")
                                (ipv6? data))
                               ((string=? f "uri")
                                (uri? data))
                               ((string=? f "uri-reference")
                                (uri-reference? data))
                               ((string=? f "uri-template")
                                (uri-template? data))
                               ((string=? f "json-pointer")
                                (json-pointer? data))
                               (else
                                (log-error "Unknown format: " f)
                                #f))
                         (valid-w/o? 'format))))
                 (else
                  #t)))
          (else
           #f)))
  (and (ejsexpr? data)
       (ejsexpr? schema)
       (json-schema? schema)
       (valid? data schema)))

(provide adheres-to-schema?)

(define (check-json/schema data schema)
  (cond ((not (ejsexpr? data))
         (let-values ([(data/jsexpr data-well-formed?)
                       (parse-json data)])
           (if data-well-formed?
               (check-json/schema data/jsexpr schema)
               (raise-argument-error 'data "well-formed" data))))
        ((not (ejsexpr? schema))
         (let-values ([(schema/jsexpr schema-well-formed?)
                       (parse-json schema)])
           (if schema-well-formed?
               (check-json/schema data schema/jsexpr)
               (raise-argument-error 'schema "well-formed" schema))))
        ((not (json-schema? schema))
         (raise-argument-error 'schema "JSON Schema" schema))
        ((not (adheres-to-schema? data schema))
         (error "Data does not adhere to schema."))
        (else
         void)))

(module+ test
  ;; (check-exn exn:fail:contract? (lambda () (check-json/schema 'no-way (hasheq))))
  ;; (check-exn exn:fail:contract? (lambda () (check-json/schema "frothy" 'jose)))
  ;; (check-exn exn:fail:contract? (lambda () (check-json/schema 5 5)))
  ;; (check-exn exn:fail? (lambda () (check-json/schema 0 #f)))
  (let-test ([js "right about now"]
             [schema #t])
     (check-true (ejsexpr? js))
     (check-true (json-schema? schema))
     (check-eq? void (check-json/schema js schema))))

(provide check-json/schema)
